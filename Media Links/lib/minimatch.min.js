/**
 * Lightweight glob pattern matching for browser
 * Provides minimatch-like API for domain/URL pattern matching
 * Supports: *, ?, **, character classes [abc], negation [!abc]
 */
(function(global) {
  'use strict';

  /**
   * Convert a glob pattern to a RegExp
   * @param {string} pattern - Glob pattern
   * @param {object} options - Options (nocase, dot, etc.)
   * @returns {RegExp}
   */
  function makeRe(pattern, options) {
    options = options || {};

    if (!pattern || typeof pattern !== 'string') {
      return /(?:)/; // matches empty string
    }

    // Escape special regex characters except glob wildcards
    let regexStr = '';
    let i = 0;
    const len = pattern.length;

    while (i < len) {
      const char = pattern[i];

      if (char === '*') {
        // Check for **
        if (pattern[i + 1] === '*') {
          // ** matches anything including /
          regexStr += '.*';
          i += 2;
          // Skip trailing /
          if (pattern[i] === '/') i++;
        } else {
          // * matches anything except /
          regexStr += '[^/]*';
          i++;
        }
      } else if (char === '?') {
        // ? matches any single character except /
        regexStr += '[^/]';
        i++;
      } else if (char === '[') {
        // Character class
        let classEnd = pattern.indexOf(']', i + 1);
        if (classEnd === -1) {
          // No closing bracket, treat as literal
          regexStr += '\\[';
          i++;
        } else {
          let classContent = pattern.slice(i + 1, classEnd);
          // Handle negation
          if (classContent[0] === '!' || classContent[0] === '^') {
            classContent = '^' + classContent.slice(1);
          }
          regexStr += '[' + classContent + ']';
          i = classEnd + 1;
        }
      } else if (char === '{') {
        // Brace expansion {a,b,c}
        let braceEnd = pattern.indexOf('}', i + 1);
        if (braceEnd === -1) {
          regexStr += '\\{';
          i++;
        } else {
          let alternatives = pattern.slice(i + 1, braceEnd).split(',');
          regexStr += '(?:' + alternatives.map(escapeRegex).join('|') + ')';
          i = braceEnd + 1;
        }
      } else if (char === '\\' && i + 1 < len) {
        // Escape sequence
        regexStr += '\\' + pattern[i + 1];
        i += 2;
      } else if ('.+^$|()'.indexOf(char) !== -1) {
        // Escape regex special characters
        regexStr += '\\' + char;
        i++;
      } else {
        regexStr += char;
        i++;
      }
    }

    // Anchor the pattern
    regexStr = '^' + regexStr + '$';

    try {
      return new RegExp(regexStr, options.nocase ? 'i' : '');
    } catch (e) {
      console.warn('minimatch: Invalid pattern', pattern, e);
      return /(?!)/; // matches nothing
    }
  }

  /**
   * Escape special regex characters in a string
   */
  function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  /**
   * Test if a string matches a glob pattern
   * @param {string} str - String to test
   * @param {string} pattern - Glob pattern
   * @param {object} options - Options
   * @returns {boolean}
   */
  function minimatch(str, pattern, options) {
    options = options || {};

    if (!str || typeof str !== 'string') return false;
    if (!pattern || typeof pattern !== 'string') return false;

    // Handle negation patterns
    let negate = false;
    if (pattern[0] === '!') {
      negate = true;
      pattern = pattern.slice(1);
    }

    // Quick literal match check (no glob characters)
    if (!/[*?[\]{}]/.test(pattern)) {
      const match = options.nocase
        ? str.toLowerCase() === pattern.toLowerCase()
        : str === pattern;
      return negate ? !match : match;
    }

    const regex = makeRe(pattern, options);
    const match = regex.test(str);

    return negate ? !match : match;
  }

  /**
   * Create a filter function for use with Array.filter
   * @param {string} pattern - Glob pattern
   * @param {object} options - Options
   * @returns {function}
   */
  minimatch.filter = function(pattern, options) {
    return function(str) {
      return minimatch(str, pattern, options);
    };
  };

  /**
   * Match a string against multiple patterns
   * @param {string[]} list - List of strings to match
   * @param {string} pattern - Glob pattern
   * @param {object} options - Options
   * @returns {string[]}
   */
  minimatch.match = function(list, pattern, options) {
    return list.filter(minimatch.filter(pattern, options));
  };

  /**
   * Create a RegExp from a glob pattern
   */
  minimatch.makeRe = makeRe;

  /**
   * Minimatch class for reusable pattern matching
   */
  function Minimatch(pattern, options) {
    this.pattern = pattern;
    this.options = options || {};
    this.regex = makeRe(pattern, this.options);
    this.negate = pattern && pattern[0] === '!';
  }

  Minimatch.prototype.match = function(str) {
    return minimatch(str, this.pattern, this.options);
  };

  Minimatch.prototype.makeRe = function() {
    return this.regex;
  };

  minimatch.Minimatch = Minimatch;

  // Export
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = minimatch;
  }
  global.minimatch = minimatch;

})(typeof window !== 'undefined' ? window : this);
